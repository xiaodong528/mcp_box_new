[
  {
    "mcp_tool_name": "getMiddleFaultCause",
    "mcp_tool_code": "\n\n@mcp.tool(\n    description='中间件故障解决方案',\n    annotations={\n        \"parameters\": {\n            \"faultCode\": {\"description\": \"故障代码\"},\n            \"severity\": {\"description\": \"故障严重等级，1-5，默认为1\"}\n        }\n    }\n)\ndef getMiddleFaultCause(\n    faultCode: str,\n    severity: int=1\n    ):\n    print(f\"getMiddleFaultCause: faultCode={faultCode}, severity={severity}\")\n    faultCause = \"\"\n    if (faultCode == 'F03'):\n        faultCause = \"中间件redis故障，重启redis\"\n    else:\n        faultCause = f\"未知故障，故障代码{faultCode}\"        \n    return {'result': 0, 'faultCause': faultCause}\n"
  },
  {
    "mcp_tool_name": "memo.create",
    "mcp_tool_code": "\n\"\"\"\n<requirements>\nhttpx>=0.27.0\n</requirements>\n\"\"\"\nimport os\nfrom typing import List, Optional, Any, Dict\nimport httpx\n\nAPI_BASE_URL = os.getenv(\"MEMO_API_URL\", \"http://127.0.0.1:48000\")\n\ndef _http_request(\n    method: str,\n    path: str,\n    json_data: Optional[Dict[str, Any]] = None,\n    params: Optional[Dict[str, Any]] = None,\n) -> Any:\n    \"\"\"封装 HTTP 请求,统一错误处理\"\"\"\n    url = f\"{API_BASE_URL}{path}\"\n    try:\n        response = httpx.request(\n            method=method,\n            url=url,\n            json=json_data,\n            params=params,\n            timeout=10.0,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        response.raise_for_status()\n        return response.json()\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ValueError(\"Memo 不存在\")\n        else:\n            try:\n                error_detail = e.response.json().get(\"detail\", e.response.text)\n            except Exception:\n                error_detail = e.response.text\n            raise ValueError(f\"API 错误: {e.response.status_code} - {error_detail}\")\n    except httpx.RequestError as e:\n        raise ValueError(f\"无法连接到 API 服务器 ({API_BASE_URL}): {str(e)}\")\n\n@mcp.tool(\n    description='创建一条新的备忘录',\n    annotations={\n        \"parameters\": {\n            \"title\": {\"description\": \"备忘录标题\"},\n            \"content\": {\"description\": \"备忘录内容\"},\n            \"tags\": {\"description\": \"标签列表，可选，默认为空列表\"}\n        }\n    }\n)\ndef memo_create(title: str, content: str, tags: Optional[List[str]] = None) -> Dict[str, Any]:\n    \"\"\"创建一条新的备忘录,并返回完整记录\"\"\"\n    payload = {\"title\": title, \"content\": content, \"tags\": tags or []}\n    data = _http_request(\"POST\", \"/memos\", json_data=payload)\n    return data\n"
  },
  {
    "mcp_tool_name": "memo.get",
    "mcp_tool_code": "\n\"\"\"\n<requirements>\nhttpx>=0.27.0\n</requirements>\n\"\"\"\nimport os\nfrom typing import Any, Dict, Optional\nimport httpx\n\nAPI_BASE_URL = os.getenv(\"MEMO_API_URL\", \"http://127.0.0.1:48000\")\n\ndef _http_request(\n    method: str,\n    path: str,\n    json_data: Optional[Dict[str, Any]] = None,\n    params: Optional[Dict[str, Any]] = None,\n) -> Any:\n    \"\"\"封装 HTTP 请求,统一错误处理\"\"\"\n    url = f\"{API_BASE_URL}{path}\"\n    try:\n        response = httpx.request(\n            method=method,\n            url=url,\n            json=json_data,\n            params=params,\n            timeout=10.0,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        response.raise_for_status()\n        return response.json()\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ValueError(\"Memo 不存在\")\n        else:\n            try:\n                error_detail = e.response.json().get(\"detail\", e.response.text)\n            except Exception:\n                error_detail = e.response.text\n            raise ValueError(f\"API 错误: {e.response.status_code} - {error_detail}\")\n    except httpx.RequestError as e:\n        raise ValueError(f\"无法连接到 API 服务器 ({API_BASE_URL}): {str(e)}\")\n\n@mcp.tool(\n    description='根据 id 查询备忘录',\n    annotations={\n        \"parameters\": {\n            \"memo_id\": {\"description\": \"备忘录 ID\"}\n        }\n    }\n)\ndef memo_get(memo_id: int) -> Dict[str, Any]:\n    \"\"\"根据 id 查询备忘录,不存在则抛出错误\"\"\"\n    data = _http_request(\"GET\", f\"/memos/{memo_id}\")\n    return data\n"
  },
  {
    "mcp_tool_name": "memo.list",
    "mcp_tool_code": "\n\"\"\"\n<requirements>\nhttpx>=0.27.0\n</requirements>\n\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional\nimport httpx\n\nAPI_BASE_URL = os.getenv(\"MEMO_API_URL\", \"http://127.0.0.1:48000\")\n\ndef _http_request(\n    method: str,\n    path: str,\n    json_data: Optional[Dict[str, Any]] = None,\n    params: Optional[Dict[str, Any]] = None,\n) -> Any:\n    \"\"\"封装 HTTP 请求,统一错误处理\"\"\"\n    url = f\"{API_BASE_URL}{path}\"\n    try:\n        response = httpx.request(\n            method=method,\n            url=url,\n            json=json_data,\n            params=params,\n            timeout=10.0,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        response.raise_for_status()\n        return response.json()\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ValueError(\"Memo 不存在\")\n        else:\n            try:\n                error_detail = e.response.json().get(\"detail\", e.response.text)\n            except Exception:\n                error_detail = e.response.text\n            raise ValueError(f\"API 错误: {e.response.status_code} - {error_detail}\")\n    except httpx.RequestError as e:\n        raise ValueError(f\"无法连接到 API 服务器 ({API_BASE_URL}): {str(e)}\")\n\n@mcp.tool(\n    description='按更新时间倒序列出备忘录,支持搜索与分页',\n    annotations={\n        \"parameters\": {\n            \"search\": {\"description\": \"搜索关键词，可选，搜索标题和内容\"},\n            \"limit\": {\"description\": \"返回结果数量限制，可选\"},\n            \"offset\": {\"description\": \"分页偏移量，默认为 0\"}\n        }\n    }\n)\ndef memo_list(search: Optional[str] = None, limit: Optional[int] = None, offset: int = 0) -> List[Dict[str, Any]]:\n    \"\"\"按更新时间倒序列出备忘录,支持搜索与分页\"\"\"\n    params = {}\n    if search:\n        params[\"search\"] = search\n    if limit is not None:\n        params[\"limit\"] = limit\n    if offset:\n        params[\"offset\"] = offset\n    data = _http_request(\"GET\", \"/memos\", params=params)\n    return data\n"
  },
  {
    "mcp_tool_name": "memo.update",
    "mcp_tool_code": "\n\"\"\"\n<requirements>\nhttpx>=0.27.0\n</requirements>\n\"\"\"\nimport os\nfrom typing import Any, Dict, List, Optional\nimport httpx\n\nAPI_BASE_URL = os.getenv(\"MEMO_API_URL\", \"http://127.0.0.1:48000\")\n\ndef _http_request(\n    method: str,\n    path: str,\n    json_data: Optional[Dict[str, Any]] = None,\n    params: Optional[Dict[str, Any]] = None,\n) -> Any:\n    \"\"\"封装 HTTP 请求,统一错误处理\"\"\"\n    url = f\"{API_BASE_URL}{path}\"\n    try:\n        response = httpx.request(\n            method=method,\n            url=url,\n            json=json_data,\n            params=params,\n            timeout=10.0,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        response.raise_for_status()\n        return response.json()\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ValueError(\"Memo 不存在\")\n        else:\n            try:\n                error_detail = e.response.json().get(\"detail\", e.response.text)\n            except Exception:\n                error_detail = e.response.text\n            raise ValueError(f\"API 错误: {e.response.status_code} - {error_detail}\")\n    except httpx.RequestError as e:\n        raise ValueError(f\"无法连接到 API 服务器 ({API_BASE_URL}): {str(e)}\")\n\n@mcp.tool(\n    description='更新指定备忘录的字段',\n    annotations={\n        \"parameters\": {\n            \"memo_id\": {\"description\": \"备忘录 ID\"},\n            \"title\": {\"description\": \"新标题，可选\"},\n            \"content\": {\"description\": \"新内容，可选\"},\n            \"tags\": {\"description\": \"新标签列表，可选\"}\n        }\n    }\n)\ndef memo_update(\n    memo_id: int,\n    title: Optional[str] = None,\n    content: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n) -> Dict[str, Any]:\n    \"\"\"更新指定字段并返回更新后的备忘录\"\"\"\n    payload = {}\n    if title is not None:\n        payload[\"title\"] = title\n    if content is not None:\n        payload[\"content\"] = content\n    if tags is not None:\n        payload[\"tags\"] = tags\n    data = _http_request(\"PUT\", f\"/memos/{memo_id}\", json_data=payload)\n    return data\n"
  },
  {
    "mcp_tool_name": "memo.delete",
    "mcp_tool_code": "\n\"\"\"\n<requirements>\nhttpx>=0.27.0\n</requirements>\n\"\"\"\nimport os\nfrom typing import Any, Dict, Optional\nimport httpx\n\nAPI_BASE_URL = os.getenv(\"MEMO_API_URL\", \"http://127.0.0.1:48000\")\n\ndef _http_request(\n    method: str,\n    path: str,\n    json_data: Optional[Dict[str, Any]] = None,\n    params: Optional[Dict[str, Any]] = None,\n) -> Any:\n    \"\"\"封装 HTTP 请求,统一错误处理\"\"\"\n    url = f\"{API_BASE_URL}{path}\"\n    try:\n        response = httpx.request(\n            method=method,\n            url=url,\n            json=json_data,\n            params=params,\n            timeout=10.0,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        response.raise_for_status()\n        return response.json()\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ValueError(\"Memo 不存在\")\n        else:\n            try:\n                error_detail = e.response.json().get(\"detail\", e.response.text)\n            except Exception:\n                error_detail = e.response.text\n            raise ValueError(f\"API 错误: {e.response.status_code} - {error_detail}\")\n    except httpx.RequestError as e:\n        raise ValueError(f\"无法连接到 API 服务器 ({API_BASE_URL}): {str(e)}\")\n\n@mcp.tool(\n    description='删除指定 id 的备忘录',\n    annotations={\n        \"parameters\": {\n            \"memo_id\": {\"description\": \"备忘录 ID\"}\n        }\n    }\n)\ndef memo_delete(memo_id: int) -> Dict[str, Any]:\n    \"\"\"删除指定 id 的备忘录,返回删除结果\"\"\"\n    data = _http_request(\"DELETE\", f\"/memos/{memo_id}\")\n    return data\n"
  }
]